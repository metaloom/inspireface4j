/*
#include <iostream>
#include <string>
#include <string.h>
#include <memory>
#include <inspirecv/inspirecv.h>
//#include "inspireface/initialization_module/launch.h"
//#include <inspireface/launch.h>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
//#include <inspireface/middleware/inspirecv_image_process.h>
#include "inspireface/track_module/landmark/face_landmark_adapt.h"
#include "InspireFace/3rdparty/InspireCV/src/test/common/inspirecv_image_process.h"
*/

/*
int main()
{
    //    std::string sourcePathStr = "test_res/data/bulk/pedestrian.png";
    initializeSession();
    cv::Mat image = cv::imread(sourcePathStr, cv::IMREAD_COLOR);
    detect(image);
    releaseSession();
    return 0;
}
*/
    /*
        HFImageStream imgHandle;
        HResult ret = CVImageToImageStream(image, imgHandle);
        if (ret != HSUCCEED)
        {
            HFLogPrint(HF_LOG_ERROR, "Failed to convert cv image: %d", ret);
            return NULL;
        }
    */

    /*
        // Copy a new image to draw
        HFImageBitmap drawImage = {0};
        ret = HFImageBitmapCopy(image, &drawImage);
        if (ret != HSUCCEED)
        {
            HFLogPrint(HF_LOG_ERROR, "Copy ImageBitmap error: %d", ret);
            return multipleFaceData;
        }
        HFImageBitmapData data;
        ret = HFImageBitmapGetData(drawImage, &data);
        if (ret != HSUCCEED)
        {
            HFLogPrint(HF_LOG_ERROR, "Get ImageBitmap data error: %d", ret);
            return multipleFaceData;
        }
    */

HFImageStream loadImageStream(std::string sourcePathStr)
{
    // Load a image
    HFImageBitmap image;
    HPath sourcePath = sourcePathStr.c_str();
    HResult ret = HFCreateImageBitmapFromFilePath(sourcePath, 3, &image);
    if (ret != HSUCCEED)
    {
        HFLogPrint(HF_LOG_ERROR, "The source entered is not a picture or read error.");
        return NULL;
    }

    HFImageStream imageStream = loadImage(sourcePathStr);
    return imageStream;
}

/*
extern "C" void initialize(const char *labelsPath, const char *modelPath, bool useGPU)
{
    printf("Initializing YoloLib using model %s - labels %s - Using GPU: %s\n", modelPath, labelsPath, useGPU ? "true" : "false");
    fflush(stdout);
}


extern "C" void detect(cv::Mat *imagePtr, bool drawBoundingBoxes)
{
     cv::Mat cvimage = *imagePtr;

    std::string expansion_path = "";
    INSPIRE_LAUNCH->Load("test_res/pack/Pikachu");
    auto archive = INSPIRE_LAUNCH->getMArchive();

    inspire::InspireModel lmkModel;
    auto ret = archive.LoadModel("landmark", lmkModel);
    if (ret != 0) {
        INSPIRE_LOGE("Load %s error: %d", "landmark", ret);
        return;
    }

    inspire::FaceLandmarkAdapt lmk;
    lmk.loadData(lmkModel, lmkModel.modelType);

    // Load and resize image using OpenCV
    if (cvimage.empty()) {
        std::cerr << "Failed to load image!" << std::endl;
        return;
    }

    cv::Mat resized;
    cv::resize(cvimage, resized, cv::Size(112, 112));

    //auto data = image.Resize(112, 112);
    //auto image = inspirecv::Image image(*cvimage);
    inspirecv::Image image(resized.cols,resized.rows,resized.channels(), resized.data);



    auto lmk_out = lmk(image);
    std::vector<inspirecv::Point2i> landmarks_output(inspire::FaceLandmarkAdapt::NUM_OF_LANDMARK);
    for (int i = 0; i < inspire::FaceLandmarkAdapt::NUM_OF_LANDMARK; ++i) {
        float x = lmk_out[i * 2 + 0] * image.Width();
        float y = lmk_out[i * 2 + 1] * image.Height();
        landmarks_output[i] = inspirecv::Point<int>(x, y);
    }


    for (int i = 0; i < landmarks_output.size(); ++i) {
        image.DrawCircle(landmarks_output[i], 5, {0, 0, 255});
    }
    image.Write("crop_lmk.png");

/*
    for (const auto& pt : landmarks_output) {
      cv::circle(image, pt, 5, cv::Scalar(0, 0, 255), -1); // red dot
    }
    cv::imwrite("crop_lmk.png", image);
    */
// }
